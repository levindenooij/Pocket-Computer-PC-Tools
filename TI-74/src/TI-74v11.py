# unresolved issues : 	how to retrieve original variable names# work around :			program allocates variable from A,B,etc based on hexcode present 0X20, 0x21, etcimport csvimport sysimport numpy as npdef find_token(hex_value):  # hex to token conversion takes place here	with open('./resources/Token.csv',newline='') as Token:		tokenDict = (csv.DictReader(Token, delimiter=',',quotechar='@'))		tokenDictList = [row for row in tokenDict]		token=None		space=None				for row in tokenDictList:				if row['hexvalue'] == hex_value:				token=row['Token']				space=row['Space']		return token,space					with open('./resources/Extended_Token.csv', newline='') as Extended:				extendedDict= (csv.DictReader(Extended, delimiter=',', quotechar='@'))		extendedDictList = [row for row in extendedDict]def skip_bytes(section_start, section_size): # just skip the bytes	return section_start+section_sizedef get_file_name(data,section_start, section_size): # extract filename from data	print("File : ", end="") 	for dec_value in data[section_start+3:section_start+section_size]:		if dec_value == 0: # once 0 zero encountered then stop				break		else:			if dec_value in range (30,127): # alpha numeric character				print(chr(dec_value),end="")	print("")	return section_start + section_size	def get_file_stats(data,section_start): #extract block properties	num_bytes=int.from_bytes(data[section_start+1:section_start+2],'little')	num_blocks= int.from_bytes(data[section_start+3:section_start+4],'little') # one section = 64 bytes	rem_bytes=int.from_bytes(data[section_start+4:section_start+5],'little')	print("source length = ", end="") 	print(num_bytes)	print("number of complete blocks =",end="")	print(num_blocks)	print("bytes in last incomplete block = ",end="")	print(rem_bytes)	return num_bytes,num_blocks,rem_bytes	def process_alpha_character(byte_value): # convert into alpha character	if byte_value in range (30,127): # alpha numeric character		print(chr(byte_value),end="")			def process_block(data,section_start, block_size, source, source_index): # extract code from  a  block	pointer=section_start	while pointer < section_start+block_size: 		source[source_index]=data[pointer]		source_index+=1		pointer+=1	return pointer, source_index	def process_code(code): # process tehe remaining code and convert	alpha_mode=False	use_quotes=False	digit_value=0	hex_value="0xFF"	new_line=False	prev_hex_value='0xFF'		code_index=0	while code_index < len(code):		prev_hex_value=hex_value		hex_value='0x'+ hex(code[code_index])[2:4].zfill(2).upper() # make an uppercase hex string for compliance with Token file		if hex_value=="0xFF": # last FF encountered skip the rest			break		if hex_value!='0x00' and prev_hex_value=='0x00': # new line encountered			if hex_value=="0x8B":				print(":",end="")				print("PAUSE",end="")			else:				print('\n')				line_number=code[code_index]				print(line_number, end=" ")				code_index+=2 # skip the number of characters. so no false new lines		else:			if alpha_mode:				process_alpha_character(code[code_index])				char_count-=1				if char_count==0:					if use_quotes==True:						print('"',end="")						use_quotes=False					alpha_mode=False			else: # is it a number?				# EE notation is for 1.23x10**5 is 1.23 5 Youe get two Cx after each other.				if hex_value >='0xC2' and hex_value <='0xC8':						total_num_bytes=int(hex_value[3])-1  # total number of bytes follown 0xC. First byte is is the number_part						code_index+=1 # move to number part						if code[code_index]==0:							code_index+=1							str_value=str(code[code_index])						else:							if code[code_index]-63 >= 0:  #x03F is 0 bytes as whole number								whole_num_bytes=code[code_index]-63								frac_num_bytes=total_num_bytes-whole_num_bytes							else:								whole_num_bytes=0								frac_num_bytes=abs(code[code_index]-63)															str_value=""							for i in range(1, whole_num_bytes+1): # process all whole bytes								code_index+=1								int_value=int.from_bytes(code[code_index:code_index+1],'big')								low_nibble=int_value & 15								high_nibble=int_value >> 4								if i==1 and high_nibble ==0:									str_value+=""								else:									str_value+=str(high_nibble)  	# add high_nibble to string								str_value+=str(low_nibble)		# add low_nibble to string							if frac_num_bytes > 0:								str_value+="0."							for i in range(1, frac_num_bytes+1):								code_index+=1								int_value=int.from_bytes(code[code_index:code_index+1],'big')								low_nibble=int_value & 15								high_nibble=int_value >> 4								str_value+=str(high_nibble)  	# add high_nibble to string								str_value+=str(low_nibble)		# add low_nibble to string						print(str_value,end=" ")																	else: # is it a string?					if hex_value=='0xC9' or hex_value=='0xCA':						alpha_mode=True						code_index+=1  # find number of characters						char_count=code[code_index] # find number of characters						if hex_value=='0xC9':							use_quotes=True							print('"',end="")						else:							token,space=find_token(hex_value)						if token!=None:							print(token, end="")							if space=='x':   # add space after STATEMENT								print(" ", end="")		code_index+=1	return 0				def main():	with open ('./bin/factorial.bin','rb') as f: # read the bin file into a binary array		data=f.read()				# START SKIPPING USELESS DATA		section_start=0		skip_arr1=np.array((1208,1,31,1))		for i in range (np.size(skip_arr1)):			section_size=skip_arr1[i]			section_start=skip_bytes(section_start,section_size) 					## FILE SECTION STARTS HERE		section_size=25		section_start=get_file_name(data,section_start,section_size)						# CONTINUE SKIPPING USELESS DATA		skip_arr2=np.array((1,1208,1,23,1,1208,1))		for i in range (np.size(skip_arr2)):			section_size=skip_arr2[i]			section_start=skip_bytes(section_start,section_size) 			## SECTION WITH STATS STARTS HERE				num_bytes,num_blocks,rem_bytes = get_file_stats(data,section_start) #we need this info to controle the block processing				# CONTINUE SKIPPING USELESS DATA		section_size=31 # move pointer 31 bytes		section_start=skip_bytes(section_start,section_size) #				section_size=1 # check if xFF		#print(byte_value(section_start, section_size))		section_start=skip_bytes(section_start,section_size) ## skip the FF value				## SECTION WITH INSTRUCTION BLOCKS STARTS HERE			# this comes in blocks of 64 , earlier we learned how many complete blocks and the number of bytes in the last "incomplete block"		# first block starts with 80 xx xx then structure 00 linenumber 00 code repeates for each line		# block is concluded with checksum 		# 8 zeros and FF follows on 64 block.		# block is repeated		# we extract the code from the block structure so we we can process in one qo later				block_size=64		code_index=0		code = bytearray(num_bytes)		if num_blocks >=1: # process first complete block			section_start,code_index = process_block(data,section_start+3, block_size-3, code,code_index) # skip 80 xx xx			section_start+=1 # skip block checksum			section_start+=8+1 # skip 8 zeros and FF			section_start+=block_size+1 # skip repetition			section_start+=8+1 # skip 8 zeros and FF		for i in range(1,num_blocks): # process next number of complete blocks			section_start,code_index = process_block(data,section_start, block_size,code,code_index)			section_start+=1 # skip block checksum			section_start+=8+1 # skip 8 zeros and FF			section_start+=block_size+1 # skip repetition			section_start+=8+1 # skip 8 zeros and FF		if rem_bytes > 0: # process the the only uncomplete block			block_size=rem_bytes			section_start,code_index = process_block(data,section_start, block_size,code,code_index)			section_start+=8+1 # skip 8 zeros+FF			section_start+=block_size+1 # skip repetition			section_start+=8+1 # skip 8 zeros and FF				process_code(code) # now we only have code, we can process it seperately			return 0	if __name__ == '__main__':	sys.exit(main())